bridge {
  // This id must be different for every JMS Bridge cluster otherwise they will all cluster together.
  // Each node in the cluster must share this ID or they will operate as independent clusters.
  id = default

  // All standard kafka client options can be specified in this block. They will be used for every
  // client connection that the JMS Bridge requires including:
  //  1. Consumers
  //  2. Admin clients
  //  3. Producers
  //  4. Kafka Streams clients
  // See https://docs.confluent.io/current/clients/java.html#java-client
  //
  // TLS and principal settings can be applied uniformly from this block.
  kafka {
    // This is the only required parameter and indicates how to reach the Kafka cluster.
    bootstrap.servers = "localhost:9092"
  }

////////////
//
//   SECURITY CONFIGURATION (JAAS)
//     See JAAS Security Manager section at
//         https://activemq.apache.org/components/artemis/documentation/latest/security.html
//
////////////
#  security {
#    // The security domain that will be used by JAAS and is configured via the system property
#    // 'java.security.auth.login.config' which should point to a valid JAAS configuration file.
#    // This is a required setting.
#    domain = "MyDomain"
#
#    // The security domain that will be used for certificate based authentication via  JAAS.
#    // It is also configured via the file pointed to by the 'java.security.auth.login.config'
#    // system property.
#    // This is an optional setting
#    certificate-domain = "MyCertDomain"
#  }


////////////
//
//  JOURNAL CONFIGURATION
//
//  All journal configuration is optional with the exception that for environments with less than
//  3 Kafka brokers in the cluster the replication will need to be adjusted to the number of
//  available Kafka brokers, e.g. 1 or 2.
//
////////////

#    journals {
#
#      // Used to enforce max message size at the JMS level and also used as an option on any
#      // auto created journal topic.
#      max.message.size = 1m
#
#      // The maximum amount of time to wait for the journals to load and become ready. Journals
#      // with a lot of data can take a considerable amount of time to load.
#      ready.timeout = 60s
#
#      // How often to check for the readiness of the journal
#      ready.check.interval = 1s
#
#      // This topic configuration applies to all journals and is used when journal topics are auto
#      // created. Journal topics created outside of the JMS Bridge should follow the guidelines here.
#      topic {
#
#        // for environments without 3 or more brokers set this to the number of brokers available
#        replication = 3
#
#        //Using more than one partition is experimental, by default 1 is used.
#        partitions = 1
#
#        options {
#          // add any topic options you may want, by default we set segment.bytes to 128mb for
#          // performance reasons.
#          segment.bytes = "134217728"
#        }
#      }
#
#      // This block can be used to specify a previously prepared topic to use for the bindings
#      // journal by setting the name and override any options specified in the 'journals.topic'
#      // block.
#      bindings {
#
#        // Specify the exact topic to use by name, creates it if it does not exist.
#        name = "my-binding-journal-topic"
#
#        // by default the bindings topic uses the same settings as the journal configuration
#        topic = ${bridge.journals.topic}
#      }
#
#      // This block can be used to specify a previously prepared topic to use for the messages
#      // journal by setting the name and override any options specified in the 'journals.topic'
#      // block.
#      messages {
#
#        // Specify the exact topic to use by name, creates it if it does not exist.
#        name = "my-binding-journal-topic"
#
#        // by default the messages topic uses the same settings as the journal configuration
#        topic = ${bridge.journals.topic}
#      }
#    }

////////////
//
//  ROUTING CONFIGURATION
//
// All routing configuration is optional. If none is specified than the JMS Bridge will not
// synchronize data between top level Kafka topics and the corresponding JMS topics.
//
////////////
#    routing = {
#
#      // This determines how often the JMS Bridge should perform topic discovery against Kafka and
#      // update the match results. Changes can occur when topics are created/deleted or ACLs are changed
#      // that impact what topics the JMS Bridge is authorized to read/write from. By default it is
#      // set to 5 minutes.
#      metadata.refresh.ms = "300000"
#
#      // Add a topic match which controls what topics will by synced. Topics matching this rule
#      // will have incoming / outgoing messages handled using the options specified.
#      //
#      // You can have multiple topic routing rules.
#      topics = [
#       {
#
#         // REQUIRED, must be set, can be any regular expression. Determines what topics are
#         // handled by this rule (if any) by comparing the regular expression to the Kakfa topic'
#         // name.
#         match = null
#
#         // For every matched topic a JMS topic (address) will be created that JMS clients can bind
#         // to for receiving messages from Kafka or send to for publishing messages to Kafka. This
#         // determines what the name of that JMS topic will be. The only replacement token available
#         // is `${topic}` which is replaced by the full Kafka topic name.
#         address.template = "kafka.${topic}"
#
#          // What JMS message type should be used for messages coming from Kafka. By default 'BYTES'
#          // but 'TEXT' is also an option. This can be overridden by Kafka publishers by setting
#          // the 'jms.JMSType' record header to either 'BYTES' or 'TEXT'.
#          message.type = "BYTES"
#
#          // The JMS property to use as the Kafka record key when publishing to kafka.
#          key.property = "JMSMessageID"
#
#          // If a correlation key is present on the JMS Message then use that instead of the property
#          // specified by 'key.property'
#          correlation.key.override = true
#
#
#          // Always consume and route messages from the matching Kafka topics regardless of whether
#          // anybody is listening (no bindings). This is required for situations where data may be
#          // routed to destinations that may not be bound to the corresponding JMS topic
#          // ( e.g. request/reply pattern using the `jms.JMSDestination` header).
#          //
#          // Normally, to conserver resources, if a topic exchange is not bound (no queue or consumer
#          // attached to the JMS topic) then no data will be read from the corresponding Kafka topic
#          // since it will not be routed.
#          consume.always = false
#        }
#      ]
#    }
}