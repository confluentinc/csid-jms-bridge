syntax = "proto3";

option java_multiple_files = true;
option java_package = "io.confluent.amq.persistence.domain.proto";
option java_outer_classname = "JournalRecordProto";
option objc_class_prefix = "KJR";

package kafkajournal;


/*
These are the fundamental record types used to support the higher level messaging protocol.

The ID numbers used are scraped from ActiveMQ's value for them but through experience it has been
discovered that these IDs do not have to match AMQ's since it never reads this low level detail
except in their own journal implementations. Due to a lack of a good reason to change them
they've been left as is though.
*/
enum JournalRecordType {
  UNKNOWN_JOURNAL_RECORD_TYPE = 0;

  /*
    Adds a new message to the system and will remain until deleted.
  */
  ADD_RECORD = 11;

  /* Annotation, Update in AMQ's journals.

     Annotations are applied to messages and can contain an arbitrary amount of data with them.
     Any number of annotations can be applied to a message and they will be stored until
     the related message is deleted.
   */
  ANNOTATE_RECORD = 12;

  /*
    Transaction based ADD_RECORD that will be applied if the transaction is committed.
  */
  ADD_RECORD_TX = 13;

  /*
    Transaction based ANNOTATE_RECORD that will be applied if the transaction is committed.
  */
  ANNOTATE_RECORD_TX = 14;

  /*
    Transaction based DELETE_RECORD that will be applied if the transaction is committed.
  */
  DELETE_RECORD_TX = 15;

  /*
    Deletes a message from the system and all related annotations.
  */
  DELETE_RECORD = 16;

  /* Allows for the attachment of arbitrary data to a TX, needed to support JTA in JMS */
  PREPARE_TX = 17;

  /*
    Terminates a transaction and causes all TX records to be applied as their non-TX counterparts.
    All records that are part of the transaction will also be deleted after being applied.
  */
  COMMIT_TX = 18;

  /*
    Terminates a transaction and causes all records associated to the TX to be deleted without
    being applied.
  */
  ROLLBACK_TX = 19;
}

message JournalRecord {
  /*
    The ID of the record which is generated by the JMS Engine. For some transactional records
    this can be ZERO indicating it's a purely transactional protocol record
    (rollback, commit, prepare) and does not impact any messages directly.
  */
  int64 messageId = 1;

  /*
    Transaction ID as supplied by the MQ engine.
    If this is a TX record then this is the transaction it is associated to, otherwise it will
    default to ZERO.
    Valid values are ZERO and above.
  */
  int64 txId = 2;

  /*
    This is the extended ID which can be used to uniquely identify records that share a group ID,
    such as a transaction ID or message ID (annotations). All values are valid.
  */
  int32 extendedId = 3;

  /*
    This is used by the MQ Engine to mark what this record is in regards to their
    higher level protocol.
  */
  int32 protocolRecordType = 4;

  /*
    Low level journal type indicating if this is part of a transaction, record lifecycle or
    an annotation.
  */
  JournalRecordType recordType = 5;

  /*
    Arbitrary data associated to the protocol. Can be a message payload, annotation, transaction
    data etc.
   */
  bytes data = 6;

}

/*
  Represents a collection of all transaction record keys for a specific transaction ID.
*/
message TransactionReference {
  int64 txId = 1;
  repeated JournalEntryKey entryReferences = 2;
}

/*
  Represents a collection of all annotation record keys for a specific message ID.
*/
message AnnotationReference {
  int64 messageId = 1;
  repeated JournalEntryKey entryReferences = 2;
}

/*
  Annotations are additional information that are tied to a message. Usually the payloads
  are quite small, less than 1KB.
*/
message MessageAnnotation {
  int32 protocolRecordType = 1;
  bytes data = 2;
}

/*
  This key should be unique within the journal, if not then predecessor records will be removed
  via compaction at some point in the future (maybe 7 days or even 1 second later).

  All transactions records should have the txId populated with an ID 0 or greater.
  Transactions records that represents modifications to message state should also include
  the messageId. Transactional updates to the annotations of a message should also include the
  messageId and also an extendedId to give the update a unique key.

  For non-transactional records if it is an ADD or DELETE then only the messageId is required,
  ANNOTATE records though also require the extendedId to ensure uniqueness of the key.
*/
message JournalEntryKey {
  int64 messageId = 1;
  int64 txId = 2;
  int32 extendedId = 3;
}

/*
  Represents an entry in the journal and can be one of a newly appended journal record or
  references to group based records such annotations and transactions.
*/
message JournalEntry {
  oneof entry {
    JournalRecord appendedRecord = 1;
    TransactionReference transactionReference = 2;
    AnnotationReference annotationReference = 3;
  }
}
